use std::collections::HashSet;
use std::fs;
use std::path::{Path, PathBuf};

use clap::Parser;

use crate::cli::cli_config::PrefixUpdateConfig;
use crate::cli::LockFileUsageArgs;
use crate::lock_file::UpdateLockFileOptions;
use crate::Project;
use rattler_conda_types::{ExplicitEnvironmentEntry, ExplicitEnvironmentSpec, Platform};
use rattler_lock::{
    CondaPackage, Environment, Package, PackageHashes, PypiPackage, PypiPackageData, UrlOrPath,
};

#[derive(Debug, Parser)]
#[clap(arg_required_else_help = false)]
pub struct Args {
    /// Output directory for rendered explicit environment spec files
    pub output_dir: PathBuf,

    /// Environment to render. Can be repeated for multiple envs. Defaults to all environments
    #[arg(short, long)]
    pub environment: Option<Vec<String>>,

    /// The platform to render. Can be repeated for multiple platforms.
    /// Defaults to all platforms available for selected environments.
    #[arg(short, long)]
    pub platform: Option<Vec<Platform>>,

    /// PyPI dependencies are not supported in the conda explicit spec file.
    /// This flag allows creating the spec file even if PyPI dependencies are present.
    /// Alternatively see --write-pypi-requirements
    #[arg(long, default_value = "false")]
    pub ignore_pypi_errors: bool,

    /// Write a requirements file containing all pypi dependencies
    #[arg(long, default_value = "false", conflicts_with = "ignore_pypi_errors")]
    pub write_pypi_requirements: bool,

    #[clap(flatten)]
    pub lock_file_usage: LockFileUsageArgs,

    #[clap(flatten)]
    pub prefix_update_config: PrefixUpdateConfig,
}

fn build_explicit_spec<'a>(
    platform: &Platform,
    conda_packages: impl IntoIterator<Item = &'a CondaPackage>,
) -> miette::Result<ExplicitEnvironmentSpec> {
    let mut packages = Vec::new();

    for cp in conda_packages {
        let prec = cp.package_record();
        let mut url = cp.url().to_owned();
        let hash = prec.md5.ok_or(miette::miette!(
            "Package {} does not contain an md5 hash",
            prec.name.as_normalized()
        ))?;

        url.set_fragment(Some(&format!("{:x}", hash)));

        packages.push(ExplicitEnvironmentEntry {
            url: url.to_owned(),
        });
    }

    Ok(ExplicitEnvironmentSpec {
        platform: Some(*platform),
        packages,
    })
}

fn render_explicit_spec(
    target: impl AsRef<Path>,
    exp_env_spec: &ExplicitEnvironmentSpec,
) -> miette::Result<()> {
    if exp_env_spec.packages.is_empty() {
        return Ok(());
    }

    let mut environment = String::new();
    environment.push_str("# Generated by `pixi project export`\n");
    environment.push_str(exp_env_spec.to_spec_string().as_str());

    fs::write(target, environment)
        .map_err(|e| miette::miette!("Could not write environment file: {}", e))?;

    Ok(())
}

fn get_pypi_hash_str(package_data: &PypiPackageData) -> Option<String> {
    if let Some(hashes) = &package_data.hash {
        let h = match hashes {
            PackageHashes::Sha256(h) => format!("--hash=sha256:{:x}", h).to_string(),
            PackageHashes::Md5Sha256(_, h) => format!("--hash=sha256:{:x}", h).to_string(),
            PackageHashes::Md5(h) => format!("--hash=md5:{:x}", h).to_string(),
        };
        Some(h)
    } else {
        None
    }
}

fn render_pypi_requirements(
    target: impl AsRef<Path>,
    packages: &[PypiPackage],
) -> miette::Result<()> {
    if packages.is_empty() {
        return Ok(());
    }

    let mut reqs = String::new();

    for p in packages {
        // pip --verify-hashes does not accept hashes for local files
        let (s, include_hash) = match p.url() {
            UrlOrPath::Url(url) => (url.as_str(), true),
            UrlOrPath::Path(path) => (
                path.as_os_str()
                    .to_str()
                    .unwrap_or_else(|| panic!("Could not convert {:?} to str", path)),
                false,
            ),
        };

        // remove "direct+ since not valid for pip urls"
        let s = s.trim_start_matches("direct+");

        let hash = match (include_hash, get_pypi_hash_str(p.data().package)) {
            (true, Some(h)) => format!(" {}", h),
            (false, _) => "".to_string(),
            (_, None) => "".to_string(),
        };

        if p.is_editable() {
            reqs.push_str(&format!("-e {}{}\n", s, hash));
        } else {
            reqs.push_str(&format!("{}{}\n", s, hash));
        }
    }

    fs::write(target, reqs)
        .map_err(|e| miette::miette!("Could not write requirements file: {}", e))?;

    Ok(())
}

fn render_env_platform(
    output_dir: &Path,
    env_name: &str,
    env: &Environment,
    platform: &Platform,
    ignore_pypi_errors: bool,
    write_pypi_requirements: bool,
) -> miette::Result<()> {
    let packages = env.packages(*platform).ok_or(miette::miette!(
        "platform '{platform}' not found for env {}",
        env_name,
    ))?;

    let mut conda_packages_from_lockfile: Vec<CondaPackage> = Vec::new();
    let mut pypi_packages_from_lockfile: Vec<PypiPackage> = Vec::new();

    for package in packages {
        match package {
            Package::Conda(p) => conda_packages_from_lockfile.push(p),
            Package::Pypi(pyp) => {
                if ignore_pypi_errors {
                    tracing::warn!("ignoring PyPI package since PyPI packages are not supported");
                } else if write_pypi_requirements {
                    pypi_packages_from_lockfile.push(pyp);
                } else {
                    miette::bail!(
                        "PyPI packages are not supported. Specify `--ignore-pypi-errors` to ignore this error \
                        or `--write-pypi-requirements` to write pypi requirements to a separate requirements.txt file"
                    );
                }
            }
        }
    }

    let ees = build_explicit_spec(platform, &conda_packages_from_lockfile)?;

    tracing::info!("Creating conda explicit spec for env: {env_name} platform: {platform}");
    let target = output_dir
        .join(format!("{}-{}-conda_spec.txt", env_name, platform))
        .into_os_string();

    render_explicit_spec(target, &ees)?;

    if write_pypi_requirements {
        tracing::info!("Creating pypi requirements file for env: {env_name} platform: {platform}");
        let pypi_target = output_dir
            .join(format!("{}-{}-requirements.txt", env_name, platform))
            .into_os_string();

        render_pypi_requirements(pypi_target, &pypi_packages_from_lockfile)?;
    }

    Ok(())
}

pub async fn execute(project: Project, args: Args) -> miette::Result<()> {
    let lockfile = project
        .update_lock_file(UpdateLockFileOptions {
            lock_file_usage: args.prefix_update_config.lock_file_usage(),
            no_install: args.prefix_update_config.no_install,
            ..UpdateLockFileOptions::default()
        })
        .await?
        .lock_file;

    let mut environments = Vec::new();
    if let Some(env_names) = args.environment {
        for env_name in &env_names {
            environments.push((
                env_name.to_string(),
                lockfile
                    .environment(env_name)
                    .ok_or(miette::miette!("unknown environment {}", env_name))?,
            ));
        }
    } else {
        for (env_name, env) in lockfile.environments() {
            environments.push((env_name.to_string(), env));
        }
    };

    let mut env_platform = Vec::new();

    for (env_name, env) in environments {
        let available_platforms: HashSet<Platform> = HashSet::from_iter(env.platforms());

        if let Some(ref platforms) = args.platform {
            for plat in platforms {
                if available_platforms.contains(plat) {
                    env_platform.push((env_name.clone(), env.clone(), *plat));
                } else {
                    tracing::warn!(
                        "Platform {} not available for environment {}. Skipping...",
                        plat,
                        env_name,
                    );
                }
            }
        } else {
            for plat in available_platforms {
                env_platform.push((env_name.clone(), env.clone(), plat));
            }
        }
    }

    fs::create_dir_all(&args.output_dir).ok();

    for (env_name, env, plat) in env_platform {
        render_env_platform(
            &args.output_dir,
            &env_name,
            &env,
            &plat,
            args.ignore_pypi_errors,
            args.write_pypi_requirements,
        )?;
    }

    Ok(())
}
